# 小型固定翼无人机飞行动力学与飞行控制仿真的C++实现

此实现将使用文档中建议的Eigen库进行线性代数运算。请确保你已安装Eigen并在项目中正确链接。

代码将拆分成以下几个文件以保持模块化：

* **`CommonTypes.hpp`**：定义常用的数据结构，如状态向量和控制输入。
* **`Config.hpp`**：存储常量和无人机参数（质量、转动惯量、气动系数等）。
* **`PIDController.hpp` / `PIDController.cpp`**：通用PID控制器类。
* **`DynamicsModel.hpp` / `DynamicsModel.cpp`**：6自由度动力学模型实现。
* **`ControlSystem.hpp` / `ControlSystem.cpp`**：级联PID控制架构实现。
* **`SimulationEngine.hpp` / `SimulationEngine.cpp`**：仿真主循环及模块调用。
* **`main.cpp`**：仿真运行示例。



**编译和运行此代码的步骤：**

1. 将每段代码分别保存为对应的 `.hpp` 或 `.cpp` 文件。

2. 确保已安装Eigen库，可能需要指定Eigen头文件路径，例如 `-I /path/to/eigen/`。

3. 编译C++文件并链接，例如使用g++：

   ```bash
   g++ -std=c++17 main.cpp PIDController.cpp DynamicsModel.cpp ControlSystem.cpp SimulationEngine.cpp -I /path/to/your/eigen/library -o uav_sim
   ```

4. 运行生成的可执行文件：`./uav_sim`

这个结构提供了模块化的基础，你可以在此基础上进行扩展，例如：

* 实现更详细的气动模型。
* 添加风和湍流模型。
* 从配置文件（JSON/YAML）加载无人机参数和PID增益。
* 集成可视化工具。
* 添加更复杂的导航逻辑，实现航点跟踪。
* 实现传感器模型及噪声仿真。

示例代码中采用了设计文档中的PID增益和气动系数，具体无人机模型和性能需求可能需要对这些参数进行调优。
另外，当前用于侧向-方向运动的“占位符”气动系数必须用你飞机的实际参数替换，以保证仿真精度。





以下是代码实现示例：


---
## `CommonTypes.hpp`
该文件定义仿真中使用的基本数据结构。

```cpp
#ifndef COMMON_TYPES_HPP
#define COMMON_TYPES_HPP

#include <Eigen/Dense>

// 状态向量: \[x, y, z, u, v, w, φ, θ, ψ, p, q, r]^T
// x, y, z: 惯性坐标系下的位置
// u, v, w: 机体坐标系下的速度
// φ, θ, ψ: 欧拉角（滚转角、俯仰角、偏航角）
// p, q, r: 机体坐标系下的角速度

struct UAVState {
    Eigen::Vector3d position_earth;      // [x, y, z] in Earth frame
    Eigen::Vector3d velocity_body;       // [u, v, w] in body frame
    Eigen::Vector3d euler_angles;        // [phi, theta, psi]
    Eigen::Vector3d angular_rates_body;  // [p, q, r] in body frame

    // Convenience constructor
    UAVState() {
        position_earth.setZero();
        velocity_body.setZero();
        euler_angles.setZero();
        angular_rates_body.setZero();
    }

   // 全状态向量（12×1），用于计算导数（如需要时）

    Eigen::Matrix<double, 12, 1> getFullState() const {
        Eigen::Matrix<double, 12, 1> x;
        x.segment<3>(0) = position_earth;
        x.segment<3>(3) = velocity_body;
        x.segment<3>(6) = euler_angles;
        x.segment<3>(9) = angular_rates_body;
        return x;
    }

    void setFromFullState(const Eigen::Matrix<double, 12, 1>& x) {
        position_earth = x.segment<3>(0);
        velocity_body = x.segment<3>(3);
        euler_angles = x.segment<3>(6);
        angular_rates_body = x.segment<3>(9);
    }
};

// Control inputs from the innermost loop to the dynamics model
struct ControlInputs {
    double thrust;     // 标准化推力（例如0.0到1.0）或实际力
    double delta_a;    // 副翼偏角（弧度）
    double delta_e;    // 升降舵偏角（弧度）
    double delta_r;    // 方向舵偏角（弧度）

    ControlInputs() : thrust(0.0), delta_a(0.0), delta_e(0.0), delta_r(0.0) {}
};

// Desired values for the outer loop
struct FlightPathCommand {
    double desired_altitude;   // m
    double desired_airspeed;   // m/s
    double desired_heading;    // radians (psi_d)
    // 可选添加航路点 (x, y)，用于更高级的导航功能
};

// Outputs from outer loop controller
struct OuterLoopCommands {
    double desired_roll_phi;    // radians (phi_d)
    double desired_pitch_theta; // radians (theta_d)
    double desired_yaw_rate_r;  // rad/s (r_d)
    double thrust_command;      // 推进系统指令（例如标准化推力或直接力值）
};

// Outputs from middle loop controller (desired angular rates)
struct AttitudeRateCommands {
    double desired_roll_rate_p;   // rad/s (p_d)
    double desired_pitch_rate_q;  // rad/s (q_d)
    double desired_yaw_rate_r;    // rad/s (r_d) - can be passed from outer loop or modified
};

#endif // COMMON_TYPES_HPP
```

---
## `Config.hpp`
该文件保存仿真常量和无人机参数。对于实际应用，建议如设计文档所述，从JSON或YAML文件中加载参数以便灵活配置。


```cpp
#ifndef CONFIG_HPP
#define CONFIG_HPP

#include <Eigen/Dense>

namespace Config {
    // Simulation Parameters
    constexpr double SIMULATION_STEP_SIZE = 0.01; // s (inner loop and dynamics)
    constexpr double OUTER_LOOP_DT = 0.05;        // s (20 Hz)
    constexpr double MIDDLE_LOOP_DT = 0.02;       // s (50 Hz)
    constexpr double INNER_LOOP_DT = 0.01;        // s (100 Hz)

    // Physical constants
    constexpr double GRAVITY = 9.80665; // m/s^2

    // UAV Parameters (example values, replace with actual data)
    constexpr double MASS = 1.5; // kg
    const Eigen::Matrix3d INERTIA_TENSOR = (Eigen::Matrix3d() <<
        0.1, 0.0, 0.0,
        0.0, 0.2, 0.0,
        0.0, 0.0, 0.25).finished(); // kg*m^2 (Ixx, Iyy, Izz on diagonal for simplicity)

    // Aerodynamic Reference Values (example)
    constexpr double WING_AREA = 0.5;   // m^2 (S)
    constexpr double WING_SPAN = 2.0;   // m (b)
    constexpr double MEAN_AERO_CHORD = 0.25; // m (c_bar)
    constexpr double AIR_DENSITY = 1.225; // kg/m^3 (rho, at sea level)

    // Aerodynamic Coefficients (from document Table 3.3)
    // Longitudinal
    // 气动系数（来自文档表3.3）
    // 纵向方向

    constexpr double C_L0 = 0.2;         //
    constexpr double C_L_alpha = 5.7;    // 1/rad
    constexpr double C_D0 = 0.02;        //
    constexpr double K_induced_drag = 0.066; // (k for CD = C_D0 + k*C_L^2)
    constexpr double C_m0 = 0.05;        //
    constexpr double C_m_alpha = -0.38;  // 1/rad
    constexpr double C_L_delta_e = 0.8;  // 1/rad
    constexpr double C_m_delta_e = -1.1; // 1/rad
    // Placeholder: Damping derivatives often important but not in simple table
    // 占位符：阻尼导数通常很重要，但简单表格中未列出
    constexpr double C_L_q = 0.0; // Typically non-zero, e.g., 7.0
    constexpr double C_m_q = 0.0; // Typically non-zero, e.g., -12.0

    // Lateral-Directional (Placeholders - these need to be defined for full 6DOF)
    // Side force
    // 侧向-方向气动系数（占位符——完整6自由度模型需要定义这些）
    // 侧向力
    constexpr double C_Y0 = 0.0;
    constexpr double C_Y_beta = -0.83;    // Example value
    constexpr double C_Y_p = 0.0;
    constexpr double C_Y_r = 0.0;
    constexpr double C_Y_delta_a = 0.0;
    constexpr double C_Y_delta_r = 0.2;   // Example value (rudder side force)

    // Rolling moment
    constexpr double C_l0 = 0.0;
    constexpr double C_l_beta = -0.12;   // Example value
    constexpr double C_l_p = -0.5;       // Example value (roll damping)
    constexpr double C_l_r = 0.1;        // Example value
    constexpr double C_l_delta_a = 0.25; // Example value (aileron roll moment)
    constexpr double C_l_delta_r = 0.01; // Example value

    // Yawing moment
    constexpr double C_n0 = 0.0;
    constexpr double C_n_beta = 0.15;    // Example value (weathercock stability)
    constexpr double C_n_p = -0.05;      // Example value
    constexpr double C_n_r = -0.2;       // Example value (yaw damping)
    constexpr double C_n_delta_a = 0.01; // Example value (aileron adverse yaw)
    constexpr double C_n_delta_r = -0.1; // Example value (rudder yaw moment)

    // Propulsion
    constexpr double MAX_THRUST = 10.0; // Newtons

    // Control Surface Limits (radians)
    constexpr double MAX_AILERON_DEFLECTION = 30.0 * M_PI / 180.0;
    constexpr double MAX_ELEVATOR_DEFLECTION = 25.0 * M_PI / 180.0;
    constexpr double MAX_RUDDER_DEFLECTION = 30.0 * M_PI / 180.0;

    // PID Gains (from document Section 4)
    // Outer Loop
    constexpr double K_p_psi = 1.2;    // Heading to Roll Command (phi_d)
    constexpr double K_i_psi = 0.01;   //
    constexpr double K_p_h = 0.8;      // Altitude to Pitch Command (theta_d)
    constexpr double K_i_h = 0.005;    //
    constexpr double K_p_V = 0.5;      // Airspeed to Thrust Command
    constexpr double K_i_V = 0.02;     //
    constexpr double K_p_psi_r = 0.5;  // Yaw tracking to Yaw Rate Command (r_d) (If used)
    constexpr double K_i_psi_r = 0.02; //

    // Middle Loop (Attitude Hold)
    constexpr double K_p_phi = 5.5;    // Roll angle to Roll Rate Command (p_d)
    constexpr double K_d_phi = 1.2;    //
    constexpr double K_p_theta = 6.0;  // Pitch angle to Pitch Rate Command (q_d)
    constexpr double K_i_theta = 0.2;  //
    constexpr double K_d_theta = 1.0;  //

    // Inner Loop (Rate Damping)
    constexpr double K_p_p = 8.0;      // Roll rate to Aileron (delta_a)
    constexpr double K_d_p = 1.5;      //
    constexpr double K_p_q = 9.0;      // Pitch rate to Elevator (delta_e)
    constexpr double K_d_q = 1.8;      //
    constexpr double K_p_r = 4.0;      // Yaw rate to Rudder (delta_r)
    constexpr double K_d_r = 0.5;      //

} // namespace Config

#endif // CONFIG_HPP
```

---
## `PIDController.hpp`

```cpp
#ifndef PID_CONTROLLER_HPP
#define PID_CONTROLLER_HPP

class PIDController {
public:
    PIDController(double Kp, double Ki, double Kd, double output_min, double output_max, double integral_min, double integral_max);

    double update(double desired, double actual, double dt);
    void reset();
    void setGains(double Kp, double Ki, double Kd);

private:
    double _Kp, _Ki, _Kd;
    double _output_min, _output_max;
    double _integral_min, _integral_max;
    double _integral;
    double _previous_error;
    bool _first_run;
};

#endif // PID_CONTROLLER_HPP
```

---
## `PIDController.cpp`

```cpp
#include "PIDController.hpp"
#include <algorithm> // For std::clamp

PIDController::PIDController(double Kp, double Ki, double Kd,
                             double output_min, double output_max,
                             double integral_min, double integral_max)
    : _Kp(Kp), _Ki(Ki), _Kd(Kd),
      _output_min(output_min), _output_max(output_max),
      _integral_min(integral_min), _integral_max(integral_max),
      _integral(0.0), _previous_error(0.0), _first_run(true) {}

double PIDController::update(double desired, double actual, double dt) {
    if (dt <= 0.0) return _output_min; // Avoid division by zero or weird behavior

    double error = desired - actual;

    // Proportional term
    double P_out = _Kp * error;

    // Integral term
    _integral += error * dt;
    _integral = std::clamp(_integral, _integral_min, _integral_max); // Anti-windup
    double I_out = _Ki * _integral;

    // Derivative term
    double derivative = 0.0;
    if (!_first_run && dt > 0.0) {
        derivative = (error - _previous_error) / dt;
    }
    double D_out = _Kd * derivative;

    // Total output
    double output = P_out + I_out + D_out;

    // Update state for next iteration
    _previous_error = error;
    _first_run = false;

    return std::clamp(output, _output_min, _output_max);
}

void PIDController::reset() {
    _integral = 0.0;
    _previous_error = 0.0;
    _first_run = true;
}

void PIDController::setGains(double Kp, double Ki, double Kd) {
    _Kp = Kp;
    _Ki = Ki;
    _Kd = Kd;
}
```

---
## `DynamicsModel.hpp`

```cpp
#ifndef DYNAMICS_MODEL_HPP
#define DYNAMICS_MODEL_HPP

#include "CommonTypes.hpp"
#include "Config.hpp" // For physical parameters and aero coeffs

class IDynamicsModel {
public:
    virtual ~IDynamicsModel() = default;
    virtual void initializeState(const UAVState& initial_state) = 0;
    virtual void updateState(const ControlInputs& controls, double dt) = 0;
    virtual const UAVState& getCurrentState() const = 0;
};

class SixDOFModel : public IDynamicsModel {
public:
    SixDOFModel();
    void initializeState(const UAVState& initial_state) override;
    void updateState(const ControlInputs& controls, double dt) override;
    const UAVState& getCurrentState() const override;

private:
    UAVState _current_state;

    // Function to compute state derivatives: dx/dt = f(x, u)
    // x_full = [pos_e, vel_b, euler, ang_rates_b]^T
    Eigen::Matrix<double, 12, 1> stateDerivative(const UAVState& state, const ControlInputs& controls);

    // Helper for aerodynamic forces and moments
    void calculateAerodynamics(const UAVState& state, const ControlInputs& controls,
                               Eigen::Vector3d& forces_body, Eigen::Vector3d& moments_body);

    // Helper for gravity force in body frame
    Eigen::Vector3d gravityForceBody(const Eigen::Vector3d& euler_angles);

    // Helper for rotation matrix from body to Earth frame
    Eigen::Matrix3d getRotationMatrixBodyToEarth(const Eigen::Vector3d& euler_angles);
    // Helper for Euler angle rates transformation matrix
    Eigen::Matrix3d getEulerRatesMatrix(const Eigen::Vector3d& euler_angles);
};

#endif // DYNAMICS_MODEL_HPP
```

---
## `DynamicsModel.cpp`

```cpp
#include "DynamicsModel.hpp"
#include <cmath> // For sin, cos, tan
#include <iostream> // For debug


SixDOFModel::SixDOFModel() {
    // Initialize with a default state (e.g., on ground or specific altitude)
    _current_state.position_earth = Eigen::Vector3d(0, 0, -100); // Example: 100m altitude (NED coordinates)
    _current_state.velocity_body = Eigen::Vector3d(20, 0, 0); // Example: 20 m/s forward speed
}

void SixDOFModel::initializeState(const UAVState& initial_state) {
    _current_state = initial_state;
}

const UAVState& SixDOFModel::getCurrentState() const {
    return _current_state;
}

Eigen::Matrix3d SixDOFModel::getRotationMatrixBodyToEarth(const Eigen::Vector3d& euler_angles) {
    double phi = euler_angles.x();
    double theta = euler_angles.y();
    double psi = euler_angles.z();

    Eigen::Matrix3d R_roll;
    R_roll << 1, 0, 0,
              0, cos(phi), sin(phi),
              0, -sin(phi), cos(phi);

    Eigen::Matrix3d R_pitch;
    R_pitch << cos(theta), 0, -sin(theta),
               0, 1, 0,
               sin(theta), 0, cos(theta);

    Eigen::Matrix3d R_yaw;
    R_yaw << cos(psi), sin(psi), 0,
             -sin(psi), cos(psi), 0,
             0, 0, 1;
    // For ZYX sequence (Yaw, Pitch, Roll) to transform from Body to Earth (NED)
    // R_earth_to_body = R_roll.transpose() * R_pitch.transpose() * R_yaw.transpose()
    // R_body_to_earth = R_yaw * R_pitch * R_roll
    // However, the common aerospace sequence is Yaw-Pitch-Roll for body to inertial
    Eigen::Matrix3d R_b_e; // Body to Earth
    double cphi = cos(phi), sphi = sin(phi);
    double cth = cos(theta), sth = sin(theta);
    double cpsi = cos(psi), spsi = sin(psi);

    R_b_e(0,0) = cth*cpsi;
    R_b_e(0,1) = sphi*sth*cpsi - cphi*spsi;
    R_b_e(0,2) = cphi*sth*cpsi + sphi*spsi;

    R_b_e(1,0) = cth*spsi;
    R_b_e(1,1) = sphi*sth*spsi + cphi*cpsi;
    R_b_e(1,2) = cphi*sth*spsi - sphi*cpsi;

    R_b_e(2,0) = -sth;
    R_b_e(2,1) = sphi*cth;
    R_b_e(2,2) = cphi*cth;
    return R_b_e;
}

Eigen::Matrix3d SixDOFModel::getEulerRatesMatrix(const Eigen::Vector3d& euler_angles) {
    double phi = euler_angles.x();
    double theta = euler_angles.y();
    // Standard transformation from body rates (p,q,r) to Euler rates (phi_dot, theta_dot, psi_dot)
    // [phi_dot; theta_dot; psi_dot] = E * [p; q; r]
    Eigen::Matrix3d E;
    double cphi = cos(phi), sphi = sin(phi);
    double tth = tan(theta), scth = 1.0/cos(theta); // sec(theta)

    if (std::abs(cos(theta)) < 1e-6) { // Singularity at theta = +/- 90 deg
        // Handle singularity, e.g., by using quaternions or limiting pitch
        // For now, let's assume it won't be hit perfectly or use a very large number for tan/sec
        scth = 1e6; // A large number to avoid NaN, but this indicates an issue
        tth = sin(theta) * scth;
    }

    E << 1, sphi * tth, cphi * tth,
         0, cphi,       -sphi,
         0, sphi * scth, cphi * scth;
    return E;
}


Eigen::Vector3d SixDOFModel::gravityForceBody(const Eigen::Vector3d& euler_angles) {
    Eigen::Matrix3d R_b_e = getRotationMatrixBodyToEarth(euler_angles);
    Eigen::Vector3d gravity_earth(0, 0, Config::MASS * Config::GRAVITY); // NED: Z-axis is down
    return R_b_e.transpose() * gravity_earth; // R_e_b = R_b_e^T
}

void SixDOFModel::calculateAerodynamics(const UAVState& state, const ControlInputs& controls,
                                       Eigen::Vector3d& forces_body, Eigen::Vector3d& moments_body) {
    // Unpack state
    const Eigen::Vector3d& v_body = state.velocity_body; // u, v, w
    const Eigen::Vector3d& ang_rates = state.angular_rates_body; // p, q, r

    double u = v_body.x();
    double v = v_body.y();
    double w = v_body.z();

    double p = ang_rates.x();
    double q = ang_rates.y();
    double r = ang_rates.z();

    double delta_e = controls.delta_e;
    double delta_a = controls.delta_a;
    double delta_r = controls.delta_r;

    // Airspeed and angles
    double V_a = v_body.norm(); // Airspeed
    if (V_a < 0.1) { // Avoid division by zero at low speeds
        forces_body.setZero();
        moments_body.setZero();
        return;
    }

    double alpha = atan2(w, u); // Angle of attack
    double beta = asin(v / V_a);  // Sideslip angle (small angle approx: v/V_a, more general: asin(v/Va))

    // Dynamic pressure
    double q_bar = 0.5 * Config::AIR_DENSITY * V_a * V_a;

    // Longitudinal coefficients
    double C_L = Config::C_L0 + Config::C_L_alpha * alpha + Config::C_L_delta_e * delta_e;
    // Add C_L_q term if available: + Config::C_L_q * (Config::MEAN_AERO_CHORD / (2 * V_a)) * q;
    // Simplified: use C_L_q without normalization factor first
    C_L += Config::C_L_q * q;


    double C_D = Config::C_D0 + Config::K_induced_drag * C_L * C_L; // Parabolic drag polar

    double C_m = Config::C_m0 + Config::C_m_alpha * alpha + Config::C_m_delta_e * delta_e;
    // Add C_m_q term if available: + Config::C_m_q * (Config::MEAN_AERO_CHORD / (2 * V_a)) * q;
    C_m += Config::C_m_q * q;


    // Lateral-directional coefficients (using placeholder values from Config)
    // Normalize angular rates for aero derivatives (p_hat, q_hat, r_hat)
    // 侧向-方向气动系数（使用Config中的占位符数值）
    // 归一化角速度用于气动导数计算（p\_hat, q\_hat, r\_hat）
    double p_hat = (V_a > 1.0) ? p * Config::WING_SPAN / (2.0 * V_a) : 0.0;
    double r_hat = (V_a > 1.0) ? r * Config::WING_SPAN / (2.0 * V_a) : 0.0;

    double C_Y = Config::C_Y0 + Config::C_Y_beta * beta + Config::C_Y_p * p_hat + Config::C_Y_r * r_hat +
                 Config::C_Y_delta_a * delta_a + Config::C_Y_delta_r * delta_r;

    double C_l = Config::C_l0 + Config::C_l_beta * beta + Config::C_l_p * p_hat + Config::C_l_r * r_hat +
                 Config::C_l_delta_a * delta_a + Config::C_l_delta_r * delta_r;

    double C_n = Config::C_n0 + Config::C_n_beta * beta + Config::C_n_p * p_hat + Config::C_n_r * r_hat +
                 Config::C_n_delta_a * delta_a + Config::C_n_delta_r * delta_r;


    // Aerodynamic forces (Stability Axes -> Body Axes)
    // Assuming Lift (L) and Drag (D) are initially computed in stability axes, then rotated.
    // Or, if C_L, C_D are already body-frame coeffs (X,Z direction), then it's simpler.
    // The common approach: L is perp to V_a, D is parallel to V_a.
    // F_x_stability = -D, F_z_stability = -L
    // Rotate by alpha to get to body frame:
    // F_x_body = F_x_stability * cos(alpha) - F_z_stability * sin(alpha)
    // F_z_body = F_x_stability * sin(alpha) + F_z_stability * cos(alpha)
    // Lift = q_bar * S * C_L, Drag = q_bar * S * C_D, SideForce = q_bar * S * C_Y
    // 气动力（从稳定轴系到机体轴系）
    // 假设升力（L）和阻力（D）最初在稳定轴系中计算，然后进行旋转。
    // 或者，如果 \$C\_L\$、\$C\_D\$ 已经是机体坐标系（X, Z方向）下的系数，则更简单。
    // 常用方法：升力 L 垂直于迎角速度矢量 \$V\_a\$，阻力 D 与 \$V\_a\$ 平行。
    // 稳定轴系气动力：\$F\_{x,stability} = -D\$, \$F\_{z,stability} = -L\$
    // 通过攻角 \$\alpha\$ 旋转到机体轴系：
    // \$F\_{x,body} = F\_{x,stability} \cos\alpha - F\_{z,stability} \sin\alpha\$
    // \$F\_{z,body} = F\_{x,stability} \sin\alpha + F\_{z,stability} \cos\alpha\$
    // 升力 \$L = q\_{\bar} S C\_L\$，阻力 \$D = q\_{\bar} S C\_D\$，侧力 \$Y = q\_{\bar} S C\_Y\$

    double Lift = q_bar * Config::WING_AREA * C_L;
    double Drag = q_bar * Config::WING_AREA * C_D;
    double SideForce = q_bar * Config::WING_AREA * C_Y;

    // Assuming forces are in wind frame initially (X_w along V, Z_w down perp to V)
    // F_x_wind = -Drag, F_y_wind = SideForce, F_z_wind = -Lift
    // Transform wind to body frame (alpha for pitch, beta for yaw)
    // Simplified: Assume C_L, C_D contributions are mainly to body Z and X forces
    // This is a common simplification where C_L acts primarily as -Z_body and C_D as -X_body
    // This is not entirely accurate without full stability-to-body transformation for forces.
    // For a more standard model:
    // F_X = q_bar * S * ( C_L * sin(alpha) - C_D * cos(alpha) ) (if alpha is positive up)
    // F_Z = q_bar * S * (-C_L * cos(alpha) - C_D * sin(alpha) )
    // F_Y = q_bar * S * C_Y
    // Here, following Stevens & Lewis / Beard & McLain type representation for forces in body frame:
    // F_ax = -Drag * cos(alpha) + Lift * sin(alpha)
    // F_az = -Drag * sin(alpha) - Lift * cos(alpha)
    // F_ay = SideForce
    // 假设力最初在风轴系中（\$X\_w\$沿风速方向，\$Z\_w\$垂直于风速向下）
// \$F\_{x,wind} = -\$阻力，\$F\_{y,wind} = \$侧力，\$F\_{z,wind} = -\$升力
// 将风轴系力转换到机体轴系（俯仰角\$\alpha\$用于旋转，偏航角\$\beta\$用于侧向）
// 简化假设：\$C\_L\$和\$C\_D\$的贡献主要作用于机体轴系的Z和X方向力
// 这是常见简化，\$C\_L\$主要作为\$-Z\_{body}\$方向力，\$C\_D\$主要作为\$-X\_{body}\$方向力
// 该简化不完全准确，缺少稳定轴到机体轴力的完整变换
// 更标准模型为：
// \$F\_X = q\_{\bar} S ( C\_L \sin\alpha - C\_D \cos\alpha )\$（假设\$\alpha\$正方向向上）
// \$F\_Z = q\_{\bar} S ( -C\_L \cos\alpha - C\_D \sin\alpha )\$
// \$F\_Y = q\_{\bar} S C\_Y\$
// 这里采用Stevens & Lewis / Beard & McLain类型的机体轴力表示：
// \$F\_{ax} = -\$阻力 \$\cos\alpha + \$升力 \$\sin\alpha\$
// \$F\_{az} = -\$阻力 \$\sin\alpha - \$升力 \$\cos\alpha\$
// \$F\_{ay} = \$侧力

    forces_body.x() = q_bar * Config::WING_AREA * (C_L * sin(alpha) - C_D * cos(alpha) + 0); // Simplified C_X
    forces_body.y() = q_bar * Config::WING_AREA * C_Y;
    forces_body.z() = q_bar * Config::WING_AREA * (-C_L * cos(alpha) - C_D * sin(alpha) + 0); // Simplified C_Z

    // Aerodynamic moments (already in body frame by definition of C_l, C_m, C_n)
    moments_body.x() = q_bar * Config::WING_AREA * Config::WING_SPAN * C_l;   // L_moment
    moments_body.y() = q_bar * Config::WING_AREA * Config::MEAN_AERO_CHORD * C_m; // M_moment
    moments_body.z() = q_bar * Config::WING_AREA * Config::WING_SPAN * C_n;   // N_moment
}


Eigen::Matrix<double, 12, 1> SixDOFModel::stateDerivative(const UAVState& state, const ControlInputs& controls) {
    Eigen::Matrix<double, 12, 1> x_dot;

    // Unpack state variables
    const Eigen::Vector3d& pos_earth = state.position_earth;
    const Eigen::Vector3d& vel_body = state.velocity_body; // u, v, w
    const Eigen::Vector3d& euler = state.euler_angles;   // phi, theta, psi
    const Eigen::Vector3d& ang_rates = state.angular_rates_body; // p, q, r

    // --- Forces ---
    // Aerodynamic forces
    Eigen::Vector3d aero_forces_body;
    Eigen::Vector3d aero_moments_body;
    calculateAerodynamics(state, controls, aero_forces_body, aero_moments_body);

    // Gravity force
    Eigen::Vector3d gravity_force_b = gravityForceBody(euler);

    // Propulsion force (assuming along body x-axis)
    Eigen::Vector3d thrust_force_body(controls.thrust * Config::MAX_THRUST, 0, 0);

    Eigen::Vector3d total_forces_body = aero_forces_body + gravity_force_b + thrust_force_body;

    // --- Translational Dynamics (Body Frame Velocities) ---
    // m * (v_dot_body + omega_body x v_body) = F_body
    // v_dot_body = F_body / m - omega_body x v_body
    Eigen::Vector3d v_dot_body = (total_forces_body / Config::MASS) - ang_rates.cross(vel_body);
    x_dot.segment<3>(3) = v_dot_body; // du/dt, dv/dt, dw/dt

    // --- Rotational Dynamics ---
    // I * omega_dot_body + omega_body x (I * omega_body) = M_body
    // omega_dot_body = I_inv * (M_body - omega_body x (I * omega_body))
    Eigen::Vector3d total_moments_body = aero_moments_body;
    // Add propulsion moments if any (e.g. M_t) - assuming zero for now

    Eigen::Matrix3d I = Config::INERTIA_TENSOR;
    // If I is diagonal, I_inv is just 1/Ixx, 1/Iyy, 1/Izz. For general I, use inverse().
    Eigen::Matrix3d I_inv = I.inverse(); // Cache if I is constant and performance critical

    Eigen::Vector3d ang_accel_body = I_inv * (total_moments_body - ang_rates.cross(I * ang_rates));
    x_dot.segment<3>(9) = ang_accel_body; // dp/dt, dq/dt, dr/dt

    // --- Kinematics ---
    // Position derivative (Earth frame)
    Eigen::Matrix3d R_b_e = getRotationMatrixBodyToEarth(euler);
    Eigen::Vector3d pos_dot_earth = R_b_e * vel_body;
    x_dot.segment<3>(0) = pos_dot_earth; // dx/dt, dy/dt, dz/dt

    // Euler angle rates derivative
    Eigen::Matrix3d E_matrix = getEulerRatesMatrix(euler);
    Eigen::Vector3d euler_rates_dot = E_matrix * ang_rates;
    x_dot.segment<3>(6) = euler_rates_dot; // dphi/dt, dtheta/dt, dpsi/dt

    return x_dot;
}

void SixDOFModel::updateState(const ControlInputs& controls, double dt) {
    // RK4 Integration
    Eigen::Matrix<double, 12, 1> x0 = _current_state.getFullState();

    Eigen::Matrix<double, 12, 1> k1 = stateDerivative(_current_state, controls);

    UAVState temp_state_k2 = _current_state;
    temp_state_k2.setFromFullState(x0 + 0.5 * dt * k1);
    Eigen::Matrix<double, 12, 1> k2 = stateDerivative(temp_state_k2, controls);

    UAVState temp_state_k3 = _current_state;
    temp_state_k3.setFromFullState(x0 + 0.5 * dt * k2);
    Eigen::Matrix<double, 12, 1> k3 = stateDerivative(temp_state_k3, controls);

    UAVState temp_state_k4 = _current_state;
    temp_state_k4.setFromFullState(x0 + dt * k3);
    Eigen::Matrix<double, 12, 1> k4 = stateDerivative(temp_state_k4, controls);

    Eigen::Matrix<double, 12, 1> x_new = x0 + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4);

    _current_state.setFromFullState(x_new);

    // Normalize Euler angles (optional, but good practice for psi and phi)
    _current_state.euler_angles.x() =remainder(_current_state.euler_angles.x(), 2.0 * M_PI); // Phi to +/- PI (using remainder for -pi to pi)
    _current_state.euler_angles.z() =remainder(_current_state.euler_angles.z(), 2.0 * M_PI); // Psi to +/- PI

    // Pitch angle theta should ideally be kept within -pi/2 to pi/2 to avoid gimbal lock issues with Euler rates
    // if (_current_state.euler_angles.y() > M_PI / 2.0) _current_state.euler_angles.y() = M_PI / 2.0 - 1e-6;
    // if (_current_state.euler_angles.y() < -M_PI / 2.0) _current_state.euler_angles.y() = -M_PI / 2.0 + 1e-6;
}

```

---
## `ControlSystem.hpp`

```cpp
#ifndef CONTROL_SYSTEM_HPP
#define CONTROL_SYSTEM_HPP

#include "CommonTypes.hpp"
#include "PIDController.hpp"
#include "Config.hpp" // For PID gains

class OuterLoopController {
public:
    OuterLoopController();
    OuterLoopCommands update(const FlightPathCommand& targets, const UAVState& current_state, double dt);
    void reset();
private:
    PIDController _heading_to_roll_pid;  // psi_err -> phi_cmd
    PIDController _altitude_to_pitch_pid; // h_err -> theta_cmd
    PIDController _airspeed_to_thrust_pid; // V_err -> thrust_cmd
    // Optional: Yaw error to yaw rate command for turn coordination / direct yaw control
    PIDController _yaw_err_to_yaw_rate_pid; // psi_err -> r_cmd (as per doc "偏航跟踪")
};

class MiddleLoopController {
public:
    MiddleLoopController();
    AttitudeRateCommands update(const OuterLoopCommands& attitude_cmds, const UAVState& current_state, double dt);
    void reset();
private:
    PIDController _roll_to_roll_rate_pid;  // phi_err -> p_cmd
    PIDController _pitch_to_pitch_rate_pid; // theta_err -> q_cmd
};

class InnerLoopController {
public:
    InnerLoopController();
    ControlInputs update(const AttitudeRateCommands& rate_cmds, const UAVState& current_state, double dt);
    void reset();
private:
    PIDController _roll_rate_to_aileron_pid; // p_err -> delta_a
    PIDController _pitch_rate_to_elevator_pid; // q_err -> delta_e
    PIDController _yaw_rate_to_rudder_pid;   // r_err -> delta_r
};


class CascadedController {
public:
    CascadedController();
    void reset();
    ControlInputs update(const FlightPathCommand& targets, const UAVState& current_state,
                         bool run_outer_loop, bool run_middle_loop, bool run_inner_loop, double dt_sim);

    // To get intermediate commands if needed for logging/debugging
    OuterLoopCommands getLastOuterLoopCommands() const { return _last_outer_cmds; }
    AttitudeRateCommands getLastMiddleLoopCommands() const { return _last_attitude_rate_cmds; }

private:
    OuterLoopController _outer_loop;
    MiddleLoopController _middle_loop;
    InnerLoopController _inner_loop;

    // Store last commands from higher loops to feed to lower loops
    OuterLoopCommands _last_outer_cmds;
    AttitudeRateCommands _last_attitude_rate_cmds;
    ControlInputs _last_control_inputs; // Last computed control inputs
};


#endif // CONTROL_SYSTEM_HPP
```

---
## `ControlSystem.cpp`

```cpp
#include "ControlSystem.hpp"
#include <cmath> // For fmod, M_PI
#include <algorithm> // For std::clamp

// Helper to normalize angle difference to [-PI, PI]
double normalizeAngleError(double error) {
    error = fmod(error + M_PI, 2.0 * M_PI);
    if (error < 0) error += 2.0 * M_PI;
    return error - M_PI;
}


OuterLoopController::OuterLoopController() :
    _heading_to_roll_pid(Config::K_p_psi, Config::K_i_psi, 0.0,          // K_d for heading is 0
                         -45.0 * M_PI / 180.0, 45.0 * M_PI / 180.0,  // Roll command limits (+/- 45 deg)
                         -Config::K_i_psi * 5.0, Config::K_i_psi * 5.0), // Integral limits
    _altitude_to_pitch_pid(Config::K_p_h, Config::K_i_h, 0.0,           // K_d for altitude is 0
                           -30.0 * M_PI / 180.0, 30.0 * M_PI / 180.0, // Pitch command limits (+/- 30 deg)
                           -Config::K_i_h * 10.0, Config::K_i_h * 10.0),
    _airspeed_to_thrust_pid(Config::K_p_V, Config::K_i_V, 0.0,          // K_d for airspeed is 0
                            0.0, 1.0,                                  // Thrust command limits (normalized 0-1)
                            -Config::K_i_V * 10.0, Config::K_i_V * 10.0),
    _yaw_err_to_yaw_rate_pid(Config::K_p_psi_r, Config::K_i_psi_r, 0.0, // K_d for yaw rate is 0
                             -45.0 * M_PI / 180.0, 45.0 * M_PI / 180.0, // Yaw rate command limits (+/- 45 deg/s)
                             -Config::K_i_psi_r * 5.0, Config::K_i_psi_r * 5.0)
{}

OuterLoopCommands OuterLoopController::update(const FlightPathCommand& targets, const UAVState& current_state, double dt) {
    OuterLoopCommands cmds;

    // Heading control (generates desired roll angle phi_d)
    double heading_error = normalizeAngleError(targets.desired_heading - current_state.euler_angles.z()); // psi_d - psi
    cmds.desired_roll_phi = _heading_to_roll_pid.update(0.0, -heading_error, dt); // Control to drive error to 0

    // Altitude control (generates desired pitch angle theta_d)
    double altitude = -current_state.position_earth.z(); // Assuming NED, so z is depth. altitude = -z.
    double altitude_error = targets.desired_altitude - altitude; // h_d - h
    cmds.desired_pitch_theta = _altitude_to_pitch_pid.update(0.0, -altitude_error, dt);

    // Airspeed control (generates thrust command)
    double current_airspeed = current_state.velocity_body.norm(); // Or just use u if assuming no wind and small alpha/beta
    if (current_state.velocity_body.x() > 0) { // use u if positive, otherwise norm.
        current_airspeed = current_state.velocity_body.x();
    }
    double airspeed_error = targets.desired_airspeed - current_airspeed; // V_d - V
    cmds.thrust_command = _airspeed_to_thrust_pid.update(0.0, -airspeed_error, dt);

    // Yaw tracking (generates desired yaw rate r_d) (Can be used for coordinated turns or direct yaw control)
    // The document calls this "偏航跟踪" and provides K_p_psi_r, K_i_psi_r.
    // This might be intended for something like commanding a yaw rate to achieve the heading,
    // or for side-slip control. For now, using heading_error to command r_d.
    cmds.desired_yaw_rate_r = _yaw_err_to_yaw_rate_pid.update(0.0, -heading_error, dt);
    // Or, it could be a feed-forward term for turns: r_d = g * tan(phi_cmd) / V_a
    // For now, using the PID as per structure.

    return cmds;
}

void OuterLoopController::reset() {
    _heading_to_roll_pid.reset();
    _altitude_to_pitch_pid.reset();
    _airspeed_to_thrust_pid.reset();
    _yaw_err_to_yaw_rate_pid.reset();
}


MiddleLoopController::MiddleLoopController() :
    _roll_to_roll_rate_pid(Config::K_p_phi, 0.0, Config::K_d_phi, // Ki for roll is 0
                           -150.0 * M_PI / 180.0, 150.0 * M_PI / 180.0, // p_cmd limits (+/- 150 deg/s)
                           0.0, 0.0), // No integral
    _pitch_to_pitch_rate_pid(Config::K_p_theta, Config::K_i_theta, Config::K_d_theta,
                             -90.0 * M_PI / 180.0, 90.0 * M_PI / 180.0,  // q_cmd limits (+/- 90 deg/s)
                             -Config::K_i_theta * 2.0, Config::K_i_theta * 2.0) // Integral limits
{}

AttitudeRateCommands MiddleLoopController::update(const OuterLoopCommands& attitude_cmds, const UAVState& current_state, double dt) {
    AttitudeRateCommands rate_cmds;

    // Roll angle to roll rate command (phi_d -> p_d)
    double roll_error = normalizeAngleError(attitude_cmds.desired_roll_phi - current_state.euler_angles.x());
    rate_cmds.desired_roll_rate_p = _roll_to_roll_rate_pid.update(0.0, -roll_error, dt);

    // Pitch angle to pitch rate command (theta_d -> q_d)
    double pitch_error = normalizeAngleError(attitude_cmds.desired_pitch_theta - current_state.euler_angles.y());
    rate_cmds.desired_pitch_rate_q = _pitch_to_pitch_rate_pid.update(0.0, -pitch_error, dt);

    // Pass through desired yaw rate from outer loop (or could be modified here)
    rate_cmds.desired_yaw_rate_r = attitude_cmds.desired_yaw_rate_r;

    return rate_cmds;
}

void MiddleLoopController::reset() {
    _roll_to_roll_rate_pid.reset();
    _pitch_to_pitch_rate_pid.reset();
}

InnerLoopController::InnerLoopController() :
    _roll_rate_to_aileron_pid(Config::K_p_p, 0.0, Config::K_d_p, // Ki for p is 0
                              -Config::MAX_AILERON_DEFLECTION, Config::MAX_AILERON_DEFLECTION,
                              0.0, 0.0),
    _pitch_rate_to_elevator_pid(Config::K_p_q, 0.0, Config::K_d_q, // Ki for q is 0
                                -Config::MAX_ELEVATOR_DEFLECTION, Config::MAX_ELEVATOR_DEFLECTION,
                                0.0, 0.0),
    _yaw_rate_to_rudder_pid(Config::K_p_r, 0.0, Config::K_d_r,   // Ki for r is 0
                            -Config::MAX_RUDDER_DEFLECTION, Config::MAX_RUDDER_DEFLECTION,
                            0.0, 0.0)
{}

ControlInputs InnerLoopController::update(const AttitudeRateCommands& rate_cmds, const UAVState& current_state, double dt) {
    ControlInputs actuator_cmds;

    // Roll rate to aileron (p_d -> delta_a)
    double p_error = rate_cmds.desired_roll_rate_p - current_state.angular_rates_body.x();
    actuator_cmds.delta_a = _roll_rate_to_aileron_pid.update(0.0, -p_error, dt);

    // Pitch rate to elevator (q_d -> delta_e)
    double q_error = rate_cmds.desired_pitch_rate_q - current_state.angular_rates_body.y();
    actuator_cmds.delta_e = _pitch_rate_to_elevator_pid.update(0.0, -q_error, dt);

    // Yaw rate to rudder (r_d -> delta_r)
    double r_error = rate_cmds.desired_yaw_rate_r - current_state.angular_rates_body.z();
    actuator_cmds.delta_r = _yaw_rate_to_rudder_pid.update(0.0, -r_error, dt);
    
    // Thrust is passed through from outer loop commands typically
    // (Handled by CascadedController)

    return actuator_cmds;
}

void InnerLoopController::reset() {
    _roll_rate_to_aileron_pid.reset();
    _pitch_rate_to_elevator_pid.reset();
    _yaw_rate_to_rudder_pid.reset();
}


CascadedController::CascadedController() {
    // Initialize last commands to safe/neutral values
    _last_outer_cmds.desired_roll_phi = 0.0;
    _last_outer_cmds.desired_pitch_theta = 0.0;
    _last_outer_cmds.desired_yaw_rate_r = 0.0;
    _last_outer_cmds.thrust_command = 0.0; // Assuming 0 thrust is idle/off

    _last_attitude_rate_cmds.desired_roll_rate_p = 0.0;
    _last_attitude_rate_cmds.desired_pitch_rate_q = 0.0;
    _last_attitude_rate_cmds.desired_yaw_rate_r = 0.0;

    _last_control_inputs.thrust = 0.0;
    _last_control_inputs.delta_a = 0.0;
    _last_control_inputs.delta_e = 0.0;
    _last_control_inputs.delta_r = 0.0;
}

void CascadedController::reset() {
    _outer_loop.reset();
    _middle_loop.reset();
    _inner_loop.reset();
    // Re-initialize last commands
     _last_outer_cmds.desired_roll_phi = 0.0;
    _last_outer_cmds.desired_pitch_theta = 0.0;
    _last_outer_cmds.desired_yaw_rate_r = 0.0;
    _last_outer_cmds.thrust_command = 0.0;
    _last_attitude_rate_cmds.desired_roll_rate_p = 0.0;
    _last_attitude_rate_cmds.desired_pitch_rate_q = 0.0;
    _last_attitude_rate_cmds.desired_yaw_rate_r = 0.0;
    _last_control_inputs.thrust = 0.0;
    _last_control_inputs.delta_a = 0.0;
    _last_control_inputs.delta_e = 0.0;
    _last_control_inputs.delta_r = 0.0;
}

ControlInputs CascadedController::update(const FlightPathCommand& targets, const UAVState& current_state,
                                       bool run_outer_loop, bool run_middle_loop, bool run_inner_loop, double dt_sim) {
    if (run_outer_loop) {
        _last_outer_cmds = _outer_loop.update(targets, current_state, Config::OUTER_LOOP_DT);
    }

    if (run_middle_loop) {
        _last_attitude_rate_cmds = _middle_loop.update(_last_outer_cmds, current_state, Config::MIDDLE_LOOP_DT);
    }
    // Pass through yaw rate if not updated by middle loop, or if middle loop has its own yaw logic
    _last_attitude_rate_cmds.desired_yaw_rate_r = _last_outer_cmds.desired_yaw_rate_r;


    if (run_inner_loop) {
        _last_control_inputs = _inner_loop.update(_last_attitude_rate_cmds, current_state, Config::INNER_LOOP_DT);
        // Thrust command comes from the outer loop
        _last_control_inputs.thrust = _last_outer_cmds.thrust_command;
    }
    
    return _last_control_inputs;
}

```

---
## `SimulationEngine.hpp`

```cpp
#ifndef SIMULATION_ENGINE_HPP
#define SIMULATION_ENGINE_HPP

#include "CommonTypes.hpp"
#include "DynamicsModel.hpp"
#include "ControlSystem.hpp"
#include <memory> // For std::unique_ptr

class SimulationEngine {
public:
    SimulationEngine(std::unique_ptr<IDynamicsModel> model,
                     std::unique_ptr<CascadedController> controller);

    void initialize(const UAVState& initial_state, const FlightPathCommand& initial_targets);
    void runStep();
    const UAVState& getCurrentUAVState() const;
    double getCurrentTime() const;

private:
    std::unique_ptr<IDynamicsModel> _model;
    std::unique_ptr<CascadedController> _controller;
    FlightPathCommand _current_targets;
    double _simulation_time;
    long long _step_count; // To manage different loop frequencies

    // Simulation step size, same as inner loop and dynamics
    const double _dt_sim = Config::SIMULATION_STEP_SIZE;
};

#endif // SIMULATION_ENGINE_HPP
```

---
## `SimulationEngine.cpp`

```cpp
#include "SimulationEngine.hpp"
#include "Config.hpp" // For loop delta times

SimulationEngine::SimulationEngine(std::unique_ptr<IDynamicsModel> model,
                                   std::unique_ptr<CascadedController> controller)
    : _model(std::move(model)),
      _controller(std::move(controller)),
      _simulation_time(0.0),
      _step_count(0) {}

void SimulationEngine::initialize(const UAVState& initial_state, const FlightPathCommand& initial_targets) {
    _model->initializeState(initial_state);
    _current_targets = initial_targets;
    _simulation_time = 0.0;
    _step_count = 0;
    _controller->reset();
}

void SimulationEngine::runStep() {
    const UAVState& current_uav_state = _model->getCurrentState();

    // Determine which loops to run based on timing
    // Using simple modulo for step counts. For precise timing, use simulation_time.
    // Assuming _dt_sim is the smallest time unit (e.g., 0.01s)
    // Outer loop: 20 Hz -> 0.05s -> every 5 steps if _dt_sim = 0.01s
    // Middle loop: 50 Hz -> 0.02s -> every 2 steps if _dt_sim = 0.01s
    // Inner loop: 100 Hz -> 0.01s -> every 1 step if _dt_sim = 0.01s

    bool run_outer = (_step_count % static_cast<long long>(Config::OUTER_LOOP_DT / _dt_sim + 0.5)) == 0;
    bool run_middle = (_step_count % static_cast<long long>(Config::MIDDLE_LOOP_DT / _dt_sim + 0.5)) == 0;
    bool run_inner = (_step_count % static_cast<long long>(Config::INNER_LOOP_DT / _dt_sim + 0.5)) == 0;
    // Ensure inner loop always runs if its DT matches sim DT
    if (Config::INNER_LOOP_DT == _dt_sim) run_inner = true;


    ControlInputs actuator_commands = _controller->update(
        _current_targets,
        current_uav_state,
        run_outer,
        run_middle,
        run_inner,
        _dt_sim // dt for the innermost part of controller if logic needs it directly
    );

    _model->updateState(actuator_commands, _dt_sim);

    _simulation_time += _dt_sim;
    _step_count++;
}

const UAVState& SimulationEngine::getCurrentUAVState() const {
    return _model->getCurrentState();
}

double SimulationEngine::getCurrentTime() const {
    return _simulation_time;
}
```

---
## `main.cpp`
This is a basic example of how to use the simulation components.

```cpp
#include <iostream>
#include <fstream>
#include <iomanip> // For std::fixed, std::setprecision
#include "CommonTypes.hpp"
#include "Config.hpp"
#include "DynamicsModel.hpp"
#include "ControlSystem.hpp"
#include "SimulationEngine.hpp"
#include <memory> // For std::make_unique

int main() {
    // 1. Create simulation components
    auto model = std::make_unique<SixDOFModel>();
    auto controller = std::make_unique<CascadedController>();
    SimulationEngine engine(std::move(model), std::move(controller));

    // 2. Define initial state and targets
    UAVState initial_uav_state;
    initial_uav_state.position_earth = Eigen::Vector3d(0, 0, -100); // 100m altitude (NED)
    initial_uav_state.velocity_body = Eigen::Vector3d(20, 0, 0);   // 20 m/s forward
    initial_uav_state.euler_angles = Eigen::Vector3d(0, 0, 0);     // Level flight, north heading
    initial_uav_state.angular_rates_body.setZero();

    FlightPathCommand targets;
    targets.desired_altitude = 100.0; // m
    targets.desired_airspeed = 22.0;  // m/s
    targets.desired_heading = 0.0 * M_PI / 180.0; // Radians (North)

    engine.initialize(initial_uav_state, targets);

    // 3. Simulation loop
    double total_simulation_time = 60.0; // seconds
    std::ofstream log_file("simulation_log.csv");
    log_file << "Time,X,Y,Z,u,v,w,phi,theta,psi,p,q,r,thrust,delta_a,delta_e,delta_r,phi_cmd,theta_cmd,p_cmd,q_cmd,r_cmd\n";
    log_file << std::fixed << std::setprecision(4);


    std::cout << "Starting simulation..." << std::endl;
    std::cout << std::fixed << std::setprecision(3);

    while (engine.getCurrentTime() < total_simulation_time) {
        engine.runStep();
        const UAVState& current_state = engine.getCurrentUAVState();

        // Log data (example)
        if (static_cast<int>(engine.getCurrentTime() * 1000) % 100 == 0) { // Log every 0.1s
            log_file << engine.getCurrentTime() << ","
                     << current_state.position_earth.x() << "," << current_state.position_earth.y() << "," << current_state.position_earth.z() << ","
                     << current_state.velocity_body.x() << "," << current_state.velocity_body.y() << "," << current_state.velocity_body.z() << ","
                     << current_state.euler_angles.x() * 180.0 / M_PI << "," << current_state.euler_angles.y() * 180.0 / M_PI << "," << current_state.euler_angles.z() * 180.0 / M_PI << ","
                     << current_state.angular_rates_body.x() * 180.0 / M_PI << "," << current_state.angular_rates_body.y() * 180.0 / M_PI << "," << current_state.angular_rates_body.z() * 180.0 / M_PI << ",";

            ControlInputs actual_inputs = controller->update(targets, current_state, false,false,false,0); // get last inputs
            OuterLoopCommands ol_cmds = controller->getLastOuterLoopCommands();
            AttitudeRateCommands mid_cmds = controller->getLastMiddleLoopCommands();

            log_file << actual_inputs.thrust << "," << actual_inputs.delta_a * 180.0/M_PI << "," << actual_inputs.delta_e* 180.0/M_PI << "," << actual_inputs.delta_r* 180.0/M_PI << ","
                     << ol_cmds.desired_roll_phi * 180.0/M_PI << "," << ol_cmds.desired_pitch_theta * 180.0/M_PI << ","
                     << mid_cmds.desired_roll_rate_p * 180.0/M_PI << "," << mid_cmds.desired_pitch_rate_q * 180.0/M_PI << "," << mid_cmds.desired_yaw_rate_r * 180.0/M_PI
                     << "\n";

             // Console output for quick check
             std::cout << "T: " << engine.getCurrentTime()
                       << " Alt: " << -current_state.position_earth.z()
                       << " V: " << current_state.velocity_body.x()
                       << " Psi: " << current_state.euler_angles.z() * 180.0 / M_PI
                       << " Phi: " << current_state.euler_angles.x() * 180.0 / M_PI
                       << " Theta: " << current_state.euler_angles.y() * 180.0 / M_PI
                       << std::endl;
        }

        // Example: Change target heading after some time
        if (engine.getCurrentTime() > 30.0 && targets.desired_heading == 0.0) {
            std::cout << "Changing target heading to 45 degrees." << std::endl;
            targets.desired_heading = 45.0 * M_PI / 180.0;
        }

    }

    log_file.close();
    std::cout << "Simulation finished. Log saved to simulation_log.csv" << std::endl;

    return 0;
}

```

